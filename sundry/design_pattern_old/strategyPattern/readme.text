
策略模式

意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。

如何解决：将这些算法封装成一个一个的类，任意地替换。

关键代码：实现同一个接口。

应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。

优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。

使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。

--------------------- --------------------- ---------------------

总结简单工厂模式和策略模式
1.从类型上说：简单工厂模式属于创建型模式，而策略模式属于行为型模式。
2.接下来，看一个小例子：

 斧子有很多种，有一个工厂专门负责生产各种需求的斧子。

工厂模式：
1）根据你给出的目的来生产不同用途的斧子，例如要砍人，那么工厂生产砍人斧子，要伐木就生产伐木斧子。
2）即根据你给出一些属性来生产不同行为的一类对象返回给你。
3）关注对象创建
策略模式：
1）用工厂生产的斧子来做对应的事情，例如用砍人的斧子来砍人，用伐木的斧子来伐木。
2）即根据你给出对应的对象来执行对应的方法。
3）关注行为的选择
3.简单工厂模式：根据客户选择的条件，来帮客户创建一个对象。
 策略模式：客户给它一个创建好的对象，它来帮客户做相应的事。
---------------------
通过比较客户端的代码发现：
  简单工厂模式：将对象的选择创建交给了简单工厂类，客户端只需要输入相应的条件就可以，不用负责对象的创建，但是需要客户端自己调用算法类的方法。但是一旦需要增加新的运算类，比如开根运算，就要去修改简单工厂类。
  策略模式：对象的选择创建仍需要自己来做，但是将调用方法的职责交给了Context类。一旦需要增加新的策略需要修改客户端。

因此，简单工厂模式的缺点就是当有新的需求增加时，需要频繁的修改工厂类。只用策略模式，当有新的需求增加时需要修改的是客户端，客户端仍然承担着创建对象的职责，并没有减轻客户端的压力。而将这两种模式结合起来使用，则需要修改 Context 类，总之不是完美的。




单一职责原则

开放-封闭原则
拓展开放， 修改封闭 ，（接口实现，可插拔式）

依赖倒转原则
抽象不应该依赖细节，细节应该依赖于抽象，即面向接口编程（CPU，主板，U盘等设备，针对接口设计）

里氏代换原则（LSP）
子类必须能够替换掉它们的父类型










